@import net.prover.model.proof.Step
@import net.prover.model.proof.ReferenceMap
@import net.prover.model.HtmlHelper
@(
  step: Step,
  indentLevel: Int,
  referenceMap: ReferenceMap,
  additionalReferences: Seq[String] = Nil)

@step match {
  case assertionStep: Step.Assertion => {
    <tr class="proofRow" data-reference="@assertionStep.reference.value">
      <td>
        @for(_ <- 1 to indentLevel) { &nbsp;&nbsp; }
        Then @Html(html.referencedStatement(
          assertionStep.assertion,
          Some(assertionStep.reference.value),
          referenceMap.getReferrers(Seq(assertionStep.reference.value) ++ additionalReferences: _*)
        ).body.trim).
      </td>
      @if(assertionStep.isRearrangement) {
        <td><span class="stepInferenceId">Rearrangement</span><td>
      } else {
        @defining(HtmlHelper.findInferenceToDisplay(assertionStep.inferenceApplication)) { inference =>
          @inference.keyOption match {
            case Some(key) => {
              <td><a class="stepInferenceId" href="/books/@inference.bookKey/@inference.chapterKey/@key">@inference.name</a><td>
            }
            case None => {
              <td><span class="stepInferenceId">@inference.name</span><td>
            }
          }
        }
      }
    </tr>
  }
  case assumptionStep: Step.Assumption => {
    <tr class="proofRow">
      <td>
        @for(_ <- 1 to indentLevel) { &nbsp;&nbsp; }
        Assume @Html(html.referencedStatement(
          assumptionStep.assumption,
          Some(assumptionStep.assumptionReference.value),
          referenceMap.getReferrers(Seq(assumptionStep.assumptionReference.value, assumptionStep.reference.value) ++ additionalReferences: _*)
        ).body.trim).
      </td>
    </tr>
    @assumptionStep.steps.map { substep => @html.step(
      substep,
      indentLevel + 1,
      referenceMap,
      if (assumptionStep.steps.lastOption.contains(substep)) additionalReferences :+ assumptionStep.reference.value else Nil)
    }
  }
  case scopedVariableStep: Step.ScopedVariable => {
    @scopedVariableStep.substeps.map { substep => @html.step(
      substep,
      indentLevel,
      referenceMap,
      if (scopedVariableStep.substeps.lastOption.contains(substep)) additionalReferences :+ scopedVariableStep.reference.value else Nil)
    }
  }
  case namingStep: Step.Naming => {
    <tr class="proofRow" data-reference="@namingStep.assertionStep.reference.value">
      <td>
        @for(_ <- 1 to indentLevel) { &nbsp;&nbsp; }
        Let @{namingStep.variableName} be such that @Html(html.referencedStatement(
          namingStep.assumptionStep.assumption,
          Some(namingStep.assumptionStep.assumptionReference.value),
          referenceMap.getReferrers(
            namingStep.assumptionStep.assumptionReference.value,
            namingStep.assumptionStep.reference.value
          )).body.trim).
      </td>
      @defining(namingStep.assertionStep.inferenceApplication.inference) { inference =>
        @inference.keyOption match {
          case Some(key) => {
            <td><a class="stepInferenceId" href="/books/@inference.bookKey/@inference.chapterKey/@key">@inference.name</a><td>
          }
          case None => {
            <td class="stepInferenceId">@inference.name<td>
            }
        }
      }
    </tr>
    @namingStep.assumptionStep.steps.map { substep => @html.step(
      substep,
      indentLevel,
      referenceMap,
      if (namingStep.assumptionStep.steps.lastOption.contains(substep))
        additionalReferences ++ Seq(namingStep.reference.value, namingStep.assumptionStep.reference.value)
      else
        Nil)
    }
  }
  case _ => {
    <tr class="proofRow">
      <td>@for(_ <- 1 to indentLevel) { &nbsp;&nbsp; } Unknown step @step.getClass.getCanonicalName </td>
    </tr>
  }
}
