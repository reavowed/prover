package net.prover.refactoring

import net.prover.books.management.BookStateManager
import net.prover.entries.{StepWithContext, TypedStepWithContext}
import net.prover.exceptions.InferenceReplacementException
import net.prover.model.proof.{Step, StepReference}
import net.prover.model.proof.Step.InferenceWithPremiseDerivationsStep
import net.prover.proving.derivation.SimpleDerivation
import net.prover.proving.premiseFinding.DerivationOrTargetFinder
import net.prover.theorems.{CompoundTheoremUpdater, GetReferencedPremises, RecalculateReferences}
import net.prover.util.FunctorTypes._

import scala.util.{Failure, Success, Try}

object RederivePremises extends CompoundTheoremUpdater[Try] {
  def apply()(implicit bookStateManager: BookStateManager): Unit = {
    UpdateTheorems(_ => apply(_).get)
  }

  override def updateAutogenerated(step: Step.Autogenerated, stepWithContext: StepWithContext): Try[Step] = {
    step match {
      case step: Step.InferenceWithPremiseDerivationsStep =>
        reprove(step, stepWithContext)
      case _ =>
        super.updateAutogenerated(step, stepWithContext)
    }
  }

  private def reprove(step: Step.InferenceWithPremiseDerivationsStep, stepWithContext: StepWithContext): Try[Step] = {
    val assertionStepWithContext = TypedStepWithContext(
      step.assertionStep,
      stepWithContext.proofWithContext)(
      implicitly,
      stepWithContext.stepContext.forChild().addSteps(step.premises.flatMap(_.toProofSteps)))
    val premises = GetReferencedPremises(assertionStepWithContext).map(_.statement)
    val (knownStatements, targets) = DerivationOrTargetFinder.findDerivationsOrTargets(premises) (stepWithContext)
    if (targets.nonEmpty) {
      Failure(InferenceReplacementException("Could not rederive all premises", stepWithContext))
    } else {
      RecalculateReferences(stepWithContext.withStep(InferenceWithPremiseDerivationsStep.ifNecessary(knownStatements, step.assertionStep))).map(_._1)
    }
  }
}
