package net.prover.refactoring

import net.prover.books.management.BookStateManager
import net.prover.entries.StepWithContext
import net.prover.exceptions.InferenceReplacementException
import net.prover.model.proof.{Step, StepReference}
import net.prover.model.proof.Step.InferenceWithPremiseDerivations
import net.prover.proving.premiseFinding.DerivationOrTargetFinder
import net.prover.theorems.{CompoundTheoremUpdater, GetReferencedPremises, RecalculateReferences}
import net.prover.util.FunctorTypes._

import scala.util.{Failure, Success, Try}

object RederivePremises extends CompoundTheoremUpdater[Try] {
  def apply()(implicit bookStateManager: BookStateManager): Unit = {
    UpdateTheorems(_ => apply(_).get)
  }

  override def updateAutogenerated(step: Step.Autogenerated, stepWithContext: StepWithContext): Try[Step] = {
    step match {
      case step: Step.InferenceWithPremiseDerivations =>
        reprove(step, stepWithContext)
      case _ =>
        super.updateAutogenerated(step, stepWithContext)
    }
  }

  private def reprove(step: Step.InferenceWithPremiseDerivations, stepWithContext: StepWithContext): Try[Step] = {
    val assertionStepWithContext = stepWithContext.forSubsteps(step).atIndex(step.premiseSteps.length).get
    val premises = GetReferencedPremises(assertionStepWithContext).map(_.statement)
    val (premiseSteps, targets) = DerivationOrTargetFinder.findDerivationsOrTargets(premises) (stepWithContext)
    if (targets.nonEmpty) {
      Failure(InferenceReplacementException("Could not rederive all premises", stepWithContext))
    } else {
      RecalculateReferences(stepWithContext.withStep(InferenceWithPremiseDerivations(premiseSteps, step.assertionStep))).map(_._1)
    }
  }
}
