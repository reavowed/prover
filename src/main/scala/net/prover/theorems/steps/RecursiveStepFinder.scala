package net.prover.theorems.steps

import net.prover.model.definitions.{DeductionDefinition, GeneralizationDefinition}
import net.prover.model.entries.Theorem
import net.prover.model.entries.Theorem.Proof
import net.prover.model.{Inference, Substitutions}
import net.prover.model.expressions.Statement
import net.prover.model.proof.{Premise, Step}
import scalaz.Monoid
import scalaz.Scalaz._

abstract class RecursiveStepFinder[T : Monoid] {
  def apply(theorem: Theorem): T = theorem.proofs.toList.foldMap(apply)
  def apply(proof: Proof): T = apply(proof.steps)
  def apply(steps: Seq[Step]): T = steps.toList.foldMap(apply)

  def apply(step: Step): T = {
    step match {
      case step: Step.TargetStep => apply(step)
      case step: Step.AssertionStep => apply(step)
      case step: Step.DeductionStep => apply(step)
      case step: Step.GeneralizationStep => apply(step)
      case step: Step.NamingStep => apply(step)
      case step: Step.SubproofStep => apply(step)
      case step: Step.ElidedStep => apply(step)
      case step: Step.Autogenerated => apply(step.substeps)
    }
  }

  def apply(step: Step.TargetStep): T = {
    apply(step.statement)
  }
  def apply(step: Step.AssertionStep): T = {
    apply(step.statement) |+|
      apply(step.inference) |+|
      step.premises.toList.foldMap(apply) |+|
      apply(step.substitutions)
  }
  def apply(step: Step.DeductionStep): T = {
    apply(step.assumption) |+|
      apply(step.substeps) |+|
      apply(step.deductionDefinition)
  }
  def apply(step: Step.GeneralizationStep): T = {
    apply(step.substeps) |+|
      apply(step.generalizationDefinition)
  }
  def apply(step: Step.NamingStep): T = {
    apply(step.assumption) |+|
      apply(step.substeps) |+|
      apply(step.statement) |+|
      apply(step.inference) |+|
      step.premises.toList.foldMap(apply) |+|
      apply(step.substitutions) |+|
      apply(step.deductionDefinition) |+|
      apply(step.generalizationDefinition)
  }
  def apply(step: Step.SubproofStep): T = {
    apply(step.substeps)
  }
  def apply(step: Step.ElidedStep): T = {
    apply(step.substeps) |+| step.highlightedInference.map(apply).getOrElse(mzero[T])
  }

  def apply(statement: Statement): T
  def apply(inference: Inference.Summary): T
  def apply(premise: Premise): T
  def apply(substitutions: Substitutions): T
  def apply(deductionDefinition: DeductionDefinition): T
  def apply(generalizationDefinition: GeneralizationDefinition): T
}
