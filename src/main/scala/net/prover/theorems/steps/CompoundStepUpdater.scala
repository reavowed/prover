package net.prover.theorems.steps

import net.prover.entries.{StepWithContext, StepsWithContext}
import net.prover.model.definitions.{DeductionDefinition, GeneralizationDefinition}
import net.prover.model.expressions.Statement
import net.prover.model.proof.{Premise, Step, SubstitutionContext}
import net.prover.model.{Inference, Substitutions}
import scalaz.Monad
import scalaz.Scalaz._

abstract class CompoundStepUpdater[F[_] : Monad] {
  def apply(stepsWithContext: StepsWithContext): F[List[Step]] = {
    stepsWithContext.stepsWithContexts.toList.map(apply).sequence
  }

  def apply(stepWithContext: StepWithContext): F[Step] = {
    stepWithContext.step match {
      case step: Step.TargetStep => updateTarget(step, stepWithContext)
      case step: Step.AssertionStep => updateAssertion(step, stepWithContext)
      case step: Step.DeductionStep => updateDeduction(step, stepWithContext)
      case step: Step.GeneralizationStep => updateGeneralization(step, stepWithContext)
      case step: Step.NamingStep => updateNaming(step, stepWithContext)
      case step: Step.SubproofStep => updateSubProof(step, stepWithContext)
      case step: Step.ElidedStep => updateElided(step, stepWithContext)
      case step: Step.Autogenerated => updateAutogenerated(step, stepWithContext)
    }
  }

  def updateTarget(step: Step.TargetStep, stepWithContext: StepWithContext): F[Step] = {
    for {
      newStatement <- updateStatement(step.statement, stepWithContext)
    } yield Step.TargetStep(newStatement)
  }
  def updateAssertion(step: Step.AssertionStep,  stepWithContext: StepWithContext): F[Step] = {
    for {
      newStatement <- updateStatement(step.statement, stepWithContext)
      newInference <- updateInference(step.inference, stepWithContext)
      newPremises <- step.premises.toList.map(updatePremise(_, stepWithContext)).sequence
      newSubstitutions <- updateSubstitutions(step.substitutions, stepWithContext)
    } yield Step.AssertionStep(newStatement, newInference, newPremises, newSubstitutions)
  }
  def updateDeduction(step: Step.DeductionStep, stepWithContext: StepWithContext): F[Step] = {
    for {
      newAssumption <- updateStatement(step.assumption, stepWithContext)
      newSubsteps <- apply(stepWithContext.forSubsteps(step))
      deductionDefinition <- updateDeductionDefinition(step.deductionDefinition)
    } yield Step.DeductionStep(newAssumption, newSubsteps, deductionDefinition)
  }
  def updateGeneralization(step: Step.GeneralizationStep, stepWithContext: StepWithContext): F[Step] = {
    for {
      newSubsteps <- apply(stepWithContext.forSubsteps(step))
      generalizationDefinition <- updateGeneralizationDefinition(step.generalizationDefinition)
    } yield Step.GeneralizationStep(step.variableName, newSubsteps, generalizationDefinition)
  }
  def updateNaming(step: Step.NamingStep, stepWithContext: StepWithContext): F[Step] = {
    for {
      newAssumption <- updateStatement(step.assumption, stepWithContext.stepContext.addBoundVariable(step.variableName))
      newStatement <- updateStatement(step.statement, stepWithContext)
      newSubsteps <- apply(stepWithContext.forSubsteps(step))
      newInference <- updateInference(step.inference, stepWithContext)
      newPremises <- step.premises.toList.map(updatePremise(_, stepWithContext)).sequence
      newSubstitutions <- updateSubstitutions(step.substitutions, stepWithContext)
      deductionDefinition <- updateDeductionDefinition(step.deductionDefinition)
      generalizationDefinition <- updateGeneralizationDefinition(step.generalizationDefinition)
    } yield Step.NamingStep(
      step.variableName,
      newAssumption,
      newStatement,
      newSubsteps,
      newInference,
      newPremises,
      newSubstitutions,
      generalizationDefinition,
      deductionDefinition)
  }
  def updateSubProof(step: Step.SubproofStep, stepWithContext: StepWithContext): F[Step] = {
    for {
      newSubsteps <- apply(stepWithContext.forSubsteps(step))
    } yield Step.SubproofStep(step.name, newSubsteps)
  }
  def updateElided(step: Step.ElidedStep, stepWithContext: StepWithContext): F[Step] = {
    for {
      newSubsteps <- apply(stepWithContext.forSubsteps(step))
      newHighlightedInference <- step.highlightedInference.map(updateInference(_, stepWithContext)).sequence
    } yield Step.ElidedStep(newSubsteps, newHighlightedInference, step.description)
  }
  def updateAutogenerated(step: Step.Autogenerated, stepWithContext: StepWithContext) = {
    apply(stepWithContext.forSubsteps(step)).map(step.replaceSubsteps(_)(stepWithContext.stepProvingContext))
  }

  def updateStatement(statement: Statement, substitutionContext: SubstitutionContext): F[Statement] = Monad[F].point(statement)
  def updateInference(inference: Inference.Summary, stepWithContext: StepWithContext): F[Inference.Summary] = Monad[F].point(inference)
  def updatePremise(premise: Premise, stepWithContext: StepWithContext): F[Premise] = Monad[F].point(premise)
  def updateSubstitutions(substitutions: Substitutions, stepWithContext: StepWithContext): F[Substitutions] = Monad[F].point(substitutions)
  def updateDeductionDefinition(deductionDefinition: DeductionDefinition): F[DeductionDefinition] = Monad[F].point(deductionDefinition)
  def updateGeneralizationDefinition(generalizationDefinition: GeneralizationDefinition): F[GeneralizationDefinition] = Monad[F].point(generalizationDefinition)
}
